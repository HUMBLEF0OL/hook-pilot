const { prompt } = require("enquirer");
const path = require("path");
const fs = require("fs");
const { validateTemplate } = require("./util");
const { CONFIG_FILE } = require("./constants/directoryPaths");

const loadHookTemplates = () => {
  const filePath = path.resolve(__dirname, "hookTemplateCompatibility.json");
  const rawData = fs.readFileSync(filePath);
  return JSON?.parse(rawData || "{}");
};

const hookTemplates = loadHookTemplates();

/**
 * Prompts the user to select templates for a specific Git hook type.
 *
 * @function selectTemplate
 * @description
 * This function allows the user to choose predefined templates for a Git hook or select a custom template.
 * It supports multiple selection and validates that at least one template is selected. Templates requiring
 * additional configuration are identified, and the user is informed about them.
 *
 * @param {string} hookType - The Git hook type for which templates are being selected (e.g., "pre-commit", "commit-msg").
 *
 * @returns {Promise<string[]>} A promise that resolves to an array of selected template values.
 *
 * @throws {Error} If template selection fails due to user input or internal issues.
 *
 * @example
 * const selectedTemplates = await selectTemplate("pre-commit");
 * console.log(selectedTemplates); // ['lint', 'test', 'custom']
 */
const selectTemplate = async (hookType) => {
  try {
    const choices = hookTemplates[hookType];

    if (!choices) {
      console.error(`❌ No templates available for the ${hookType} hook.`);
      return;
    }

    const choicesWithCustom = [
      ...choices,
      { name: "Custom (create your own)", value: "custom" },
    ];

    if (!choices) {
      console.error(`❌ No templates available for the ${selectedHook} hook.`);
      return;
    }

    const { templates } = await prompt([
      {
        type: "multiselect",
        name: "templates",
        message: `Select templates for ${hookType} (Space: select, A: all, I: invert, Enter: confirm):`,
        choices: choicesWithCustom.map((choice) => ({
          name: choice?.requiresConfig
            ? `${choice.name}: requires configuration`
            : choice.name,
          value: choice.value,
        })),
        validate: (value) =>
          value.length > 0 ? true : "❌ You must select at least one template.",
      },
    ]);

    const selectedTemplates = templates.map((templateValue) => {
      return choicesWithCustom.find(
        (choice) => choice.name === templateValue.split(":")[0],
      );
    });

    const templatesNeedingConfig = selectedTemplates.filter(
      (t) => t.requiresConfig,
    );

    if (templatesNeedingConfig.length > 0) {
      console.warn(
        `⚙️ The following templates require additional configuration:`,
      );
      templatesNeedingConfig.forEach((template) => {
        console.warn(`- ${template.name}: ${template.requiresConfig}`);
      });
    }

    return selectedTemplates.map((t) => t.value);
  } catch (err) {
    console.error(`❌ Template selection failed: ${err.message}`);
    throw err;
  }
};

const copyReadConfigScript = async (dirName = ".git-hooks") => {
  const readConfigScriptPath = path.join(__dirname, "templates", "read-config");
  const destPath = path.join(process.cwd(), dirName, "read-config");
  fs.copyFileSync(readConfigScriptPath, destPath);
  fs.chmodSync(destPath, "755");
};

/**
 * Generates the merged content for a Git hook script using selected templates.
 *
 * @function generateTemplateContent
 * @description
 * Combines content from predefined or custom templates to create a complete hook script.
 * Custom templates require an absolute path, while predefined templates are loaded from the project's template directory.
 * The final content removes redundant shebang lines for clean output.
 *
 * @param {string[]} templates - Array of template names, including "custom" if applicable.
 * @param {string} hook - The name of the Git hook (e.g., "pre-commit", "commit-msg").
 *
 * @returns {Promise<string>} A promise that resolves to the merged script content as a string.
 *
 * @throws {Error} If a template file is not found or invalid.
 *
 * @example
 * const content = await generateTemplateContent(['lint', 'test'], 'pre-commit');
 * console.log(content);
 *
 * // Example output:
 * // #!/bin/sh
 * //
 * // # Generated by hookpilot
 * // # Template: lint
 * // ...linting commands...
 * //
 * // # Template: test
 * // ...testing commands...
 */
const generateTemplateContent = async (templates, hook) => {
  const dirPath = JSON?.parse(fs.readFileSync(CONFIG_FILE, "utf-8"))?.directory;
  // add shell identifier along with the path to the read-config script
  let mergedContent = `#!/bin/sh\n\n# Generated by hookpilot\n\n. "$(git rev-parse --show-toplevel)/${dirPath}/read-config"\n\n`;

  const hooksTemplate = loadHookTemplates();
  let params = {};
  for (const template of templates) {
    let templateContent = "";
    if (template === "custom") {
      const { customTemplatePath } = await prompt({
        type: "input",
        name: "customTemplatePath",
        message: "Enter the absolute path to your custom template file:",
        validate: (value) =>
          validateTemplate(value) ? true : "Invalid path or file format.",
      });
      templateContent = fs.readFileSync(customTemplatePath, "utf8");
    } else {
      const templatesDir = path.join(__dirname, "templates", hook);
      const templateFile = path.join(templatesDir, template);

      if (!fs.existsSync(templateFile)) {
        console.error(
          `❌ Template '${template}' not found in '${templatesDir}'.`,
        );
        return;
      }
      templateContent = fs.readFileSync(templateFile, "utf8");
    }
    templateContent = templateContent.replace(/^#!\/bin\/sh\s*\n?/gm, "");
    mergedContent += `# Template: ${template}\n${templateContent}\n\n`;
    params = {
      ...params,
      ...(hooksTemplate[hook].find((t) => t.value === template)?.variables ||
        {}),
    };
  }
  return { templateContent: mergedContent, params };
};

module.exports = {
  selectTemplate,
  generateTemplateContent,
  copyReadConfigScript,
};
